// SPDX-License-Identifier: MI
pragma solidity ^0.8.20;

/**
 * @title KYCVerifier
 * @dev Smart contract for verifying zero-knowledge proofs of age verification
 * 
 * This contract verifies that a user is over a certain age (typically 18)
 * without revealing their actual age, using zk-SNARKs.
 */

// This will be replaced by the actual verifier generated by snarkjs
// The verifier contract is generated from the circuit's trusted setup
interface IVerifier {
    function verifyProof(
        uint[2] memory _pA,
        uint[2][2] memory _pB,
        uint[2] memory _pC,
        uint[4] memory _pubSignals
    ) external view returns (bool);
}

contract KYCVerifier {
    IVerifier public immutable verifier;
    
    // Events
    event AgeVerified(address indexed user, uint256 indexed ageHash, bool verified);
    event IssuerAdded(uint256 indexed publicKey);
    event IssuerRemoved(uint256 indexed publicKey);
    
    // State variables
    mapping(uint256 => bool) public trustedIssuers; // Public keys of trusted KYC issuers
    mapping(address => bool) public verifiedUsers;  // Users who have successfully verified their age
    mapping(address => uint256) public userAgeHashes; // Store age hash for each verified user
    
    uint256 public constant MIN_AGE = 18; // Default minimum age requirement
    
    // Errors
    error InvalidProof();
    error UntrustedIssuer();
    error AlreadyVerified();
    error NotVerified();
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }
    
    address public owner;
    
    constructor(address _verifier) {
        verifier = IVerifier(_verifier);
        owner = msg.sender;
    }
    
    /**
     * @dev Add a trusted KYC issuer
     * @param publicKey The public key of the trusted issuer
     */
    function addTrustedIssuer(uint256 publicKey) external onlyOwner {
        trustedIssuers[publicKey] = true;
        emit IssuerAdded(publicKey);
    }
    
    /**
     * @dev Remove a trusted KYC issuer
     * @param publicKey The public key of the issuer to remove
     */
    function removeTrustedIssuer(uint256 publicKey) external onlyOwner {
        trustedIssuers[publicKey] = false;
        emit IssuerRemoved(publicKey);
    }
    
    /**
     * @dev Verify age proof using zk-SNARK
     * @param proof The zk-SNARK proof components
     * @param ageHash Hash of the user's age (Poseidon(age))
     * @param issuerPublicKey Public key of the KYC issuer
     * @param minAge Minimum required age (should be >= MIN_AGE)
     */
    function verifyAgeProof(
        uint[8] calldata proof, // [pA[0], pA[1], pB[0][0], pB[0][1], pB[1][0], pB[1][1], pC[0], pC[1]]
        uint256 ageHash,
        uint256 issuerPublicKey,
        uint256 minAge
    ) external returns (bool) {
        // Check if issuer is trusted
        if (!trustedIssuers[issuerPublicKey]) {
            revert UntrustedIssuer();
        }
        
        // Ensure minimum age requirement
        require(minAge >= MIN_AGE, "Minimum age too low");
        
        // Prepare proof components for verifier
        uint[2] memory pA = [proof[0], proof[1]];
        uint[2][2] memory pB = [[proof[2], proof[3]], [proof[4], proof[5]]];
        uint[2] memory pC = [proof[6], proof[7]];
        uint[4] memory pubSignals = [ageHash, issuerPublicKey, minAge, 1]; // Last element should be 1 for valid proof
        
        // Verify the zk-SNARK proof
        bool isValid = verifier.verifyProof(pA, pB, pC, pubSignals);
        
        if (!isValid) {
            revert InvalidProof();
        }
        
        // Mark user as verified and store their age hash
        verifiedUsers[msg.sender] = true;
        userAgeHashes[msg.sender] = ageHash;
        
        emit AgeVerified(msg.sender, ageHash, true);
        return true;
    }
    
    /**
     * @dev Check if a user has been verified
     * @param user The address to check
     * @return Whether the user has been age-verified
     */
    function isUserVerified(address user) external view returns (bool) {
        return verifiedUsers[user];
    }
    
    /**
     * @dev Get the age hash for a verified user
     * @param user The address to check
     * @return The age hash of the user (0 if not verified)
     */
    function getUserAgeHash(address user) external view returns (uint256) {
        return userAgeHashes[user];
    }
    
    /**
     * @dev Check if an issuer is trusted
     * @param publicKey The public key to check
     * @return Whether the issuer is trusted
     */
    function isTrustedIssuer(uint256 publicKey) external view returns (bool) {
        return trustedIssuers[publicKey];
    }
    
    /**
     * @dev Batch verify multiple users (gas efficient for multiple verifications)
     * @param proofs Array of proof components
     * @param ageHashes Array of age hashes
     * @param issuerPublicKeys Array of issuer public keys
     * @param minAges Array of minimum ages
     * @param users Array of user addresses
     */
    function batchVerifyAgeProofs(
        uint[8][] calldata proofs,
        uint256[] calldata ageHashes,
        uint256[] calldata issuerPublicKeys,
        uint256[] calldata minAges,
        address[] calldata users
    ) external returns (bool[] memory results) {
        require(
            proofs.length == ageHashes.length &&
            ageHashes.length == issuerPublicKeys.length &&
            issuerPublicKeys.length == minAges.length &&
            minAges.length == users.length,
            "Array lengths must match"
        );
        
        results = new bool[](proofs.length);
        
        for (uint i = 0; i < proofs.length; i++) {
            try this.verifySingleProof(
                proofs[i],
                ageHashes[i],
                issuerPublicKeys[i],
                minAges[i],
                users[i]
            ) returns (bool success) {
                results[i] = success;
            } catch {
                results[i] = false;
            }
        }
    }
    
    /**
     * @dev Internal function for batch verification
     */
    function verifySingleProof(
        uint[8] calldata proof,
        uint256 ageHash,
        uint256 issuerPublicKey,
        uint256 minAge,
        address user
    ) external returns (bool) {
        require(msg.sender == address(this), "Internal function");
        
        if (!trustedIssuers[issuerPublicKey]) {
            return false;
        }
        
        if (minAge < MIN_AGE) {
            return false;
        }
        
        uint[2] memory pA = [proof[0], proof[1]];
        uint[2][2] memory pB = [[proof[2], proof[3]], [proof[4], proof[5]]];
        uint[2] memory pC = [proof[6], proof[7]];
        uint[4] memory pubSignals = [ageHash, issuerPublicKey, minAge, 1];
        
        bool isValid = verifier.verifyProof(pA, pB, pC, pubSignals);
        
        if (isValid) {
            verifiedUsers[user] = true;
            userAgeHashes[user] = ageHash;
            emit AgeVerified(user, ageHash, true);
        }
        
        return isValid;
    }
}
